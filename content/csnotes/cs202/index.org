#+TITLE: CS202 Notes
#+OPTIONS: tex: t
#+STARTUP: latexpreview
#+AUTHOR: Berkan Şahin
#+DRAFT: true
#+DATE: 2022-03-22T08:50:00+03:00
#+katex: true

* A pretty important note
These notes are pretty disorganized at the moment, I shall (hopefully) extend some sections as I 
go through the document (which can take a few days, since the document is approximately 1.1K lines long, not
counting heaps and AVL trees). I am posting these because they /might/ be useful to someone, but I give
no guarantees on that regard.

* Study resources
These two sites contain problems that can help with the exams, interviews for jobs/internships and your problem solving skills in general

[[https://hackerrank.com][Hackerrank]]
[[https://leetcode.com][Leetcode]]

* Trees
[[https://cs.bilkent.edu.tr/~adayanik/cs202/slides/L3_Trees.pptx][Slideshow]]
** Definition of a tree
- T is a tree if
  a. It has no nodes (leaf)
  b. It has n>0 nodes which are also trees
** Tree Terminology
(Assuming the tree grows downwards)
- Parent :: The parent of a node n is the node directly above it
- Child :: The child(ren) of a node n is/are the node(s) directly below it
- Root :: The only node in a tree that has no parent
- Leaf :: A node with no children
- Siblings :: Nodes with a common parent
- Ancestor :: Ancestor of a node n is a node on the path between the root and the node n
- Descendant :: A descendant of a node n is any node on the path between n and a leaf node
- Subtree :: A subtree of a node n is a tree that has a child of n as its root
** An example tree
#+call: shot()

#+RESULTS:
[[file:./pics/220222-0901-31.png]]
- Node A has children {B, C, D, E, F, G}
- {B, C, H, I, P, Q, K, L, M, N} are *leaves*
- K, L, M are siblings (since their parent is F)
** Some properties of a tree
- NOTE: We assume that a tree is a directed graph
- A tree with N nodes has N-1 edges
- Path :: A path from node $n_1$ to $n_k$ is a sequence of nodes $n_1, n_2, n_3, ..., n_k$ such that $n_i$ is the parent of $n_{i+1}$ $(1 \le i < k)$
** Level of a node
- The number of nodes on the path from root to a node n
*** Recursive definition
- If node n is the root of the tree T, its level is 1
- If n is not the root of T, its level is 1 + the level of its parent
** Height of a tree
- The number of nodes on the longest path from the root to any leaf nodes
*** Definition 1
- If T is empty, its height is 0
- If T is not empty, its height is equal to the maximum level of its nodes
*** Recursive definition
- If T is empty, its height is 0
- If T is not empty, its height is $1 + max(height(T_1), height(T_2),..., height(T_n))$ where $T_1$ through $T_n$ are the subtrees of the root node

  #+call: shot()

  #+RESULTS:
  [[file:./pics/220222-0915-50.png]]
** Binary tree
- A binary tree is a tree where the nodes have at most two children
- Called left and right children
*** Terminology
- Left Child :: Left child of a node n is the node directly below and to the left of n
- Right Child :: Right child of a node n is the node directly below and to the right of n
- Left Subtree of node n :: A binary tree that has the left child of n as its root
- Right Subtree of node n :: A binary tree that has the right child of n as its root
*** Examples
#+call: shot()

#+RESULTS:
[[file:./pics/220222-0920-24.png]]

#+call: shot()

#+RESULTS:
[[file:./pics/220222-0920-44.png]]
*** Height of a binary tree
- Same as the height of a generic tree
*** Number of possible binary trees with n nodes
- n = 0 :: 1
  - Only the empty tree
- n = 1 :: 1
  - A tree with only the root node
- n = 2 :: 2
  - Root node + left child *OR* Root node + right child
*** The General Rule
- Add the possible subtree configurations together
- That is, for n nodes, construct a binary tree with k nodes as the left subtree and  n - 1 - k nodes as the right subtree
- Repeat for all possible k values to obtain all possible configurations
**** Mathematical expression
- If n is odd ::
  $NumBT(n) = 2 \sum_{i=0}^{(n-1)/2} (NumBT(i)NumBT(n-i-1)) + NumBT((n-1)/2)NumBT((n-1)/2)$
- If n is even ::
  $NumBT(n) = 2 \sum_{i=0}^{(n-1)/2} (NumBT(i)NumBT(n-i-1))$
*** Full Binary Tree
- A full binary tree of height h is a tree where nodes with a level < h all have 2 children
  #+call: shot()

  #+RESULTS:
  [[file:./pics/220222-0944-39.png]]

*** Complete Binary Tree
- A complete binary tree is a tree which is full down to level h - 1 with level h filled from left to right
- A binary tree of height h is complete when
  1. All nodes above the level h - 2 have 2 chlidren
  2. A node at level h - 1 has children only if all nodes to its left have 2 children
  3. A node at level h - 1 can either have 2 children or only a left child
#+call: shot()

#+RESULTS:
[[file:./pics/220222-0944-57.png]]

*** Balanced Binary Tree
- A binary tree where the height of any node's left and right subtrees differ no more than 1

*** Maximum and minimum heights of a binary tree
- The efficiency of most binary tree operations depends on tree height
  - Because most algorithms traverse the tree starting from the root node and continue down one of the subtrees
- The maximum height of a tree with n nodes is n
  - When every node has at most 1 child
- In a minimum height tree, each level must contain as many nodes as possible (except the last level)
*** Some height theorems
- A full binary tree of height h has $2^h-1$ nodes
- The minimum height of a binary tree with n nodes is $\lceil log_2{(n+1)} \rceil$

*** Tree Traversal Types
- Preorder Traversal :: visit the node before its children
- Postorder Traversal :: visit the node after its children
- Inorder Traversal :: visit left child, node, then right child
#+call: shot()

#+RESULTS:
[[file:./pics/220224-1404-11.png]]
*** The BinaryTree ADT

**** Array-based Implementation
- copied verbatim from the textbook
**** TreeNode.h
#+begin_src cpp
const int MAX_NODES = 100; 	// maximum number of nodes
typedef string TreeItemType;

class TreeNode { 			// node in the tree
private:
	TreeNode();
	TreeNode(const TreeItemType& nodeItem, int left, int right);


	TreeItemType item; 		// data portion
	int leftChild; 			// index to left child
	int rightChild; 		// index to right child

	// friend class - can access private parts
	friend class BinaryTree;
};
 
// An array of tree nodes
TreeNode[MAX_NODES] tree;
int  root;
int  free;
#+end_src
**** Notes
#+call: shot()

#+RESULTS:
[[file:./pics/220222-1010-23.png]]

#+call: shot()

#+RESULTS:
[[file:./pics/220222-1010-36.png]]

- In this implementation, we keep the indices of the children
- We use a free list to keep track of the available nodes
- Free nodes are "linked" through their ~rightChild~ field to avoid moving array items during insertion/deletion
  - ~free~ variable keeps the index of the first free node
- This is an efficient-but-dirty implementation
**** For a complete binary tree
- We can predetermine fixed indices for child nodes (since a complete binary tree is always filled from left to right)

  #+call: shot()

  #+RESULTS:
  [[file:./pics/220222-1013-28.png]]

  #+call: shot()

  #+RESULTS:
  [[file:./pics/220222-1013-46.png]]

- For the nth node of the complete binary tree
  - $2n + 1$ gives the left child
  - $2n + 2$ gives the right child
  - $(n-1) / 2$ gives the parent
    - Note that this is integer division

- If the index of a child is > node count, the child does not exist

**** Pointer-Based Implementation
- More intuitive
- Doesn't need bookkeeping for free slots
- Need to be careful w/ memory management
***** Implementation of a binary tree node
***** TreeNode.h
#+begin_src cpp
typedef string TreeItemType;

class TreeNode {            // node in the tree
private:
    TreeNode() {}
    TreeNode(const TreeItemType& nodeItem,
        TreeNode *left = NULL,
        TreeNode *right = NULL)
        :item(nodeItem),leftChildPtr(left),rightChildPtr(right) {}

    TreeItemType item;       // data portion
    TreeNode *leftChildPtr;  // pointer to left child
    TreeNode *rightChildPtr; // pointer to right child

    friend class BinaryTree;
};
#+end_src
***** TreeException.h
#+begin_src cpp
class TreeException : public exception{

private:
    string msg;

public:
	virtual const char* what() const throw()
	{
		return msg.c_str();
	}
   TreeException(const string & message =""):
	exception(), msg(message) {};
	~TreeException() throw() {};

}; // end TreeException
#+end_src

**** The BinaryTree Class
- Most methods are straightforward
- Here are some more interesting examples
***** Constructors
#+begin_src cpp
BinaryTree::BinaryTree() : root(NULL) {}

// For internal usage: directly take the node ptr as root
BinaryTree::BinaryTree(TreeNode *node) : root(node) {}

// Construct a tree with a root node
BinaryTree::BinaryTree(const ItemType& rootItem) {
    root = new TreeNode(rootItem, NULL, NULL);
}

// Construct a binary tree w/ a root node and 2 subtrees
BinaryTree::BinaryTree(const ItemType& rootItem, BinaryTree& left, BinaryTree& right) {
    root = new TreeNode(rootItem, NULL, NULL);
    attachLeftSubtree(left);
    attachRightSubtree(right);
}
#+end_src
***** Attaching subtrees
- Check the invariants for a binary tree
  1. The tree shall not be empty
  2. There shall not be an existing child
#+begin_src cpp
void BinaryTree::attachLeftSubtree(BinaryTree& left) {
    // Check invariant
    if (!isEmpty() && root->leftChildPtr == NULL) {
        root->leftChildPtr = leftTree.root;
        // Design decision: we empty the tree passed in the parameter
        leftTree.root = NULL;
    }
    // TODO notify caller (via exceptions, return param etc.) when invariants not satisfied
}
#+end_src
***** Copying the tree (Tree traversal example)
- We use preorder traversal (visit node first, then children)
- Example of a recursive operation on a tree
#+begin_src cpp
// Copy constructor
BinaryTree::BinaryTree(const BinaryTree& tree) {
		copyTree(tree.root, root);
}


// Uses preorder traversal for the copy operation
// (Visits first the node and then the left and right children)
void BinaryTree::copyTree(TreeNode *treePtr, TreeNode *& newTreePtr) const {

		if (treePtr != NULL) {		// copy node
			newTreePtr = new TreeNode(treePtr->item, NULL, NULL);
			copyTree(treePtr->leftChildPtr, newTreePtr->leftChildPtr);
			copyTree(treePtr->rightChildPtr, newTreePtr->rightChildPtr);
		}
		else
			newTreePtr = NULL;	// copy empty tree
}

#+end_src
***** Deleting a tree (Tree traversal example)
- We use postorder traversal (because the root cannot be deleted before its children)
  - Otherwise we lose the ptrs for the children --> *Memory Leak*
#+begin_src cpp
// Destructor
BinaryTree::~BinaryTree() {
		destroyTree(root);
}


// Uses postorder traversal for the destroy operation
// (Visits first the left and right children and then the node)
void BinaryTree::destroyTree(TreeNode *& treePtr) {

		if (treePtr != NULL){
			destroyTree(treePtr->leftChildPtr);
			destroyTree(treePtr->rightChildPtr);
			delete treePtr;
			treePtr = NULL;
		}
}
#+end_src
***** Tree Traversal Methods (Function Pointers)
- These methods apply a given function to each node of the tree
- They differ in their order of traversal (see Tree Traversal Types)
****** Function pointers
- Points to the address of a given function
- Example:
  #+begin_src cpp
typedef int TreeItemType;
typedef void (*FunctionType)(TreeItemType& anItem);

void apply(TreeItemType* arr, int count, FunctionType fcn) {
    for (int i = 0; i < count; i++) {
        fcn(arr[i]);
    }
}

void display(TreeItemType& i) {
    std::cout << i << std::endl;
}
int main(void) {

    TreeItemType* arr = {1,2,3,4,5,7};
    int count = 6;

    apply(arr, count, display);
    return 0;
}
  #+end_src
****** Implementation
#+begin_src cpp
public:
void BinaryTree::preorderTraverse(FunctionType visit) {
    preorder(root, visit);
}
void BinaryTree::inorderTraverse(FunctionType visit) {
    inorder(root, visit);
}
void BinaryTree::postorderTraverse(FunctionType visit) {
    postorder(root, visit);
}
private:
/* Apply function on the node first, then traverse children */
void BinaryTree::preorder(TreeNode* node, FunctionType fcn) {
    if (node == NULL) return;
    fcn(node->item);
    preorder(node->leftChildPtr, fcn);
    preorder(node->rightChildPtr, fcn);
}

// Apply function to left, node, right
void BinaryTree::inorder(TreeNode* node, FunctionType fcn) {
    if (node) {
        inorder(node->leftChildPtr, fcn);
        fcn(node->item);
        inorder(node->rightChildPtr, fcn);
    }
}

// Apply function on children first
void BinaryTree::postorder(TreeNode* node, FunctionType fcn) {
    if (node) {
        postorder(node->leftChildPtr, fcn);
        postorder(node->rightChildPtr, fcn);
        fcn(node->item);
    }
}
#+end_src
****** Complexity
 - If number of nodes = n, the traversal takes $O(n)$ time for all 3
** Binary Search Trees
- A binary tree where every node satisfies the following:
  1. All values in left subtree are smaller than the value in the node
  2. All values in right subtree are larger than the value in the node
  3. The subtrees are also BSTs
- Note that BSTs can be unbalanced
    #+call: shot()

    #+RESULTS:
    [[file:./pics/220224-1443-11.png]]
    #+call:shot()

    #+RESULTS:
    [[file:./pics/220224-1443-26.png]]

  - Makes searching less efficient
*** TreeNode class
#+begin_src cpp
class TreeNode { 	// a node in the tree
private:
		TreeNode() { }
		TreeNode(const TreeItemType& nodeItem,TreeNode *left = NULL,
							     TreeNode *right = NULL)
		: item(nodeItem), leftChildPtr(left), rightChildPtr(right){ }


		TreeItemType item; 		// a data item in the tree
		TreeNode *leftChildPtr;	// pointers to children
		TreeNode *rightChildPtr;


	// friend class - can access private parts
	friend class BinarySearchTree;
};
#+end_src
*** Searching an item in a BST
- Start at the root, then proceed to the children
  - If data in node > query, proceed to left
  - If data in node < query, proceed to right
  - If data in node == query, search is successful
#+begin_src cpp
public:
void BinarySearchTree::search(int key, TreeItemType& item) {
    retrieveItem(root, key, item);
}
private:
void BinarySearchTree::retrieveItem(TreeNode*& node, int key, TreeItemType& item) {
    if (!node) {
        item = NULL;
    } else if (key == node->item.getKey()) {
        item = node->item;
    } else if (key < node->item.getKey()) {
        retrieveItem(node->leftChildPtr, key, item);
    } else {
        retrieveItem(node->rightChildPtr, key, item);
    }
}
#+end_src
*** Insertion in a BST
- The location must satisfy the BST invariants (see definition of BST)
- The insertion point is determined via a search
#+begin_src cpp
public:
void BinarySearchTree::insert(const TreeItemType& item) {
    insertItem(root, item);
}

private:
// Assume items are unique
void BinarySearchTree::insertItem(TreeNode*& node, const TreeItemType& item) {
    if (!node) // found appropriate position
        node = new TreeNode(item, NULL, NULL);
    else if (item < node->item)
        insertItem(node->leftChildPtr, item);
    else
        insertItem(node->rightChildPtr, item);
}
#+end_src
*** Deleting a BST node
- Three possible cases:
  1. A leaf node: Delete the node
  2. A node with one child: Connect the node's child to the node's parent, then delete
  3. A node with two children: Complicated
**** Deleting a node with two children
- Find a successor for the node to be deleted
  - Successor :: The smallest node (within the subtrees of a node) that is greater than the node
- Find the leftmost node in the right subtree
- Move the data in the successor to the node to be deleted
- Delete the successor (which is easy to delete)
**** C++ implementation
#+begin_src cpp
void BinarySearchTree::findSuccessor(TreeNode *&node, int& replacement);

void BinarySearchTree::deleteNode(TreeNode *&node) {
    TreeNode *del;
    int replacement;

    // Leaf node
    if (!(nodePtr->leftChild) && !nodePtr->rightChild) {
        delete node;
        node = NULL;
    } else if (!nodePtr->rightChild) { // Only left child
        del = node;
        node = node->leftChild;
        del->leftChild = NULL;
        delete del;
    } else if (!nodePtr->leftChild) { // Only right child
        del = node
        node = node->rightChild;
        del->rightChild = NULL;
        delete del;
    } else { // Two children
        findSuccessor(node->rightChild, replacement);
        node->item = replacement;
    }
}

void BinarySearchTree::findSuccessor(TreeNode *&node, int& replacement){

    if (node->leftChild) { // Not NULL
         findSuccessor(node->leftChild, replacement);
    } else {
        TreeNode successor = node;
        replacement = successor->item;
        node = node->rightChild;
        successor->rightChild = NULL;
        delete successor;
    }
}

#+end_src
**** Analysis
- Time complexity: $O(h)$ where h = height of the bin. tree
*** Traversals
- Theorem :: Inorder traversal of a binary search tree will visit its nodes in sorted order.
- Proof :: We use proof by induction.
  - Basis :: $h = 0 \implies$ no nodes visited, the empty list is sorted.
  - Inductive Hypothesis :: Assume the theorem holds for $0 \le k < h$.
  - Proof :: Let r be the value in the root node of a BST of height h+1, $T_L$ and $T_R$ be the left and right children of the root respectively.
    Since the height of the children are < h, the theorem holds for $T_L$ and $T_L$.
    By the definition of a BST, all nodes in $T_L$ are < r and all nodes in $T_R$ are > r.
    Since inorder traversal visits $T_L$, $r$, $T_R$ in the given order, the inorder traversal of a tree with height h+1 yields a sorted list.
    Therefore the theorem holds for height h+1 if the theorem is true for heights < h.
*** Minimum height of a BST
- Complete and full BSTs have minimum height
- The height of a BST with n nodes varies from $\lceil \log_2{(n+1)} \rceil$ to $n$.
- Insertion in sorted order produces a maximum height BST.
- Insertion in random order produces a near minimum height BST.
*** How many BSTs are possible for a given set of items?
- There are $n!$ orderings possible for n unique keys
- How many BSTs are possible for n items?
  - $n = 0 \implies 1$
  - $n = 1 \implies 1$
  - $n = 2 \implies 2$
  - $n = 3 \implies 5$
- $5 < 3! = 6$
  - By the pigeonhole principle, at least one of the tree configurations are produced by two distinct orderings
  - For n = 3 this is the balanced tree
- As n increases, the probability of getting a balanced (or near-balanced) BST increases
*** Treesort
- We can use a BST to sort a given array
  1. Insert the items into a BST
  2. Perform in-order traversal
**** Analysis
- Inserting an item into a BST
  - Worst case: $O(n)$
  - Average case: $O(\log_2{n})$
- Inserting n items into a BST
  - Worst case: $O(n^2)$
  - Average case: $O(n \log_2{n})$
- In-order traversal: $O(n)$
- Copying to the array: $O(n)$
- Therefore tree sort has avg. time complexity $O(n \log_2{n})$
  - Worst case complexity $O(n^2)$
*** Saving and restoring BSTs
**** Original shape
- Use preorder traversal to save the nodes
- Insert the nodes in the order they are saved into a BST
**** Balanced
- Use in-order traversal to save the elements in sorted order
- Then construct a balanced BST from the sorted list
***** Construct balanced BST from sorted list
- Pick the middle element as root
- Use the left half of the array to construct the left subtree recursively
- Use the right half of the array to construct the right subtree recursively

#+begin_src cpp
// Note: should be friend fcn of BSTNode
BSTNode* readTree(int n, std::istream& file) {
    BSTNode* node = NULL;
    if (n > 0) {
        node = new BSTNode; // Leaf node

        node->left = readTree(n/2, file);
        node->item << file;
        node->right = readTree((n-1)/2, file);
    }

    return node;
}
#+end_src

* Tables and Priority Queues
[[https://cs.bilkent.edu.tr/~adayanik/cs202/slides/L4_Heaps.pptx][slideshow]]
** Tables
- array or linked list implementations are called linear since the items come one after another
  - Unsorted array
  - Unsorted linked list
  - Sorted array
  - Sorted linked list
- There are also nonlinear implementations such as BSTs
** Priority Queues
** Heaps
- A heap is a complete binary tree such that
  - It is empty
  - Its root contains a key greater than the keys in its children, and its children are also heaps
- This is known as a maxheap
#+call: shot()

#+RESULTS:
[[file:./pics/220303-1511-16.png]]
*** Differences between heap and BST
1. A BST is sorted, but a heap does not have an absolute order
2. A heap *must* be a complete binary tree, while a BST can have different shapes
*** TODO Deleting a node from a heap
*** TODO restoring the heap
*** TODO Heapsort
